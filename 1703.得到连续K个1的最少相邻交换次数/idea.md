* 首先移动到连续的1的区间，那么原来的1的之间的相对位置一定还是不变，因为1之间互相移动没有任何意义
* 数据量1e5，所以应该是最大O(nlogn)到O(n)的复杂度
* 因为0的位置没有任何意义，先提取出所有1的位置设为`pi数组[p1 p2 p3 ··· pm]即总共有m个1`
* 因为需要k个1连续，所以从`pi数组中提取连续的k个1的位置`，设为`ai数组[a1 a2 a3 ··· ak]长度为k的滑动窗口`
* 再设定要放到连续的1的区间的索引是`[x x+1 x+2 ··· x+k-1]`
* 此时的最小交换步数就是$$|a_{1}-x|+|a_{2}-(x+1)|+···+|a_{k}-(x+k-1)|$$即$$min\sum_{i=1}^{k}|a_{i}-(x+i-1)|$$
* 做一个映射，设$$b_{i}=a_{i}-i+1$$
* 则上式子变为$$min\sum_{i=1}^{k}|a_{i}-(x+i-1)|=min\sum_{i=1}^{k}|a_{i}-i+1-x|$$即$$min\sum_{i=1}^{k}|b_{i}-x|$$
* 问题就转化成了**lc462.最少移动次数使数组元素相等II**：移动到所有元素相等的这个元素，是所有原数组数的**中位数**，即定下来`x是bi的中位数`
* 接下来就是做题步骤：
1. 预处理成bi数组，每次分滑窗处理
2. 滑窗中位数即是x，然后用前缀和O(1)的求式子的结果
* 补充两个点
*  如何从`假设 1 的位置分别为 p0,p1,...pk-1`，单个滑窗的讨论，拓展到所有1的位置，但是不需要每次都重置滑窗，这一步也是利用了中位数的一个性质，即eg:`[a b c d] k=3`，第一个滑窗是`[a b c]`，第二个滑窗是`[b c d]`，变换后应该是第一个滑窗是`[a b-1 c-2]`，第二个滑窗是`[b c-1 d-2]`，但是为什么不需要每一次滑窗都重置，即第二个滑窗可以直接用第一个滑窗的预处理，即`[b-1 c-2 d-3]`可以代替`[b c-1 d-2]`，这也是将复杂度从n2降低到n的关键步骤
1. 从数学角度上看`(c-2)-(b-1)+(d-3)-(c-2)==(c-1)-b+(d-2)-(c-1)`，所以可以直接沿用上一个滑窗的预处理
2. 从语文上看，本质是`lc462.最少移动次数使数组元素相等II`，其实就是往中位数去凑，那么整个数组整体的移动（所有元素加或减同一个元素，在本题是滑窗内元素整体+1）并不会改变最终的步数，因为关心的是相对的差值，而不是绝对差值
* 原先按照1在nums的位置数组一定是个升序数组，而且经过预处理`bi=ai-i+1`后也一定是个升序数组（不是严格升序，但还是升序），所以还是可以直接取索引中间的就是中位数
* 整体复杂度O(n)符合题意
