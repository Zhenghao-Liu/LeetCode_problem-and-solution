/*
* 记住与运算是有0则必为0，且A&A=A
* 因为m<=n
* 所以m、n转为二进制就只有两种可能(用省略号表示后面的位数，两数都为右对齐)
* 
** 可能1：n的位数比m大
* m：   1···
* n：1······
* 那么从m到n的过程必定会经过一个数：位数和n一样，最高位为1，其他位全0
* 即:10····0
* 那么除了最高位，其他位都有0，与是有0则必0，那么结果必定为最高位不确定，剩下全为0
* 即:x0····0
* 但是m其实就可以看做在不足n的位数上补0
* m：00001···
* 所以最高位也出现了0
* 结论：n的位数比m大结果为0
* 
** 可能2：n的位数和m的位数一样
* m：1·······
* n：1·······
* 把他们当字符串来看的话
* 则m、n的左半部分总会有相同的地方(因为位数一样，所以最少都有个"1"相同)
* 而剩下右边不同的地方，你会发现那边不同的地方进行按数字范围与答案必为全0
* 我们假设右边不同的只有1位，那就只有[0],[1]两种情况，按范围与必为0
* 假设右边不同的有2位，那就是[00],[01],[10],[11]，范围与也必定为0
* 以此类推(其实有点递归的思想，因为不同的有2位，那么这两位的左边一位必定是0和1，那么右边那位必然会经过0)
* 得出右边不同部分，按范围与必定为0
* 所以我们的答案其实就是
* 设右边不同部分位数有index个
* 左边相同的部分+index个0
*
** 这里用到左移右移(把他用在二进制上去理解)
* A = 0011 1101
* A<<2=1111 0100 即左移是往左移动，在最右边补0
* A>>2=0000 1111 即右移是往右移动，把右边的数给吞掉
* 我们同时把m、n一直向右移
* 若m==0 && n!=0则是可能1的情况，即n的位数比m大
* 若m==n则是可能2的情况，即m、n位数一样
*/
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int index=0;
        while (m!=0 && m!=n)
        {
            m=m>>1;
            n=n>>1;
            ++index;
        }
        if (m==0 && n!=0)
            return 0;
        else
            return m<<index;
    }
};
